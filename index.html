<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="crosshair"></div>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 2; // Start player above ground

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -25;
        dirLight.shadow.camera.right = 25;
        dirLight.shadow.camera.top = 25;
        dirLight.shadow.camera.bottom = -25;
        scene.add(dirLight);

        // World Generation
        const worldSize = 40;
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshLambertMaterial({ color: 0x44aa44 }); // Grass green

        const mesh = new THREE.InstancedMesh(geometry, material, worldSize * worldSize);
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        let index = 0;

        // World Data
        const world = new Map(); // Key: "x,y,z", Value: true

        function getChunkKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        for (let x = 0; x < worldSize; x++) {
            for (let z = 0; z < worldSize; z++) {
                const wx = x - worldSize / 2;
                const wz = z - worldSize / 2;
                dummy.position.set(wx, 0, wz);
                dummy.updateMatrix();
                mesh.setMatrixAt(index++, dummy.matrix);

                // Populate world data
                world.set(getChunkKey(wx, 0, wz), true);
            }
        }
        mesh.instanceMatrix.needsUpdate = true;

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    if (canJump) {
                        velocity.y += 12; // Jump force
                        canJump = false;
                    }
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Physics variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Player dimensions
        const playerHeight = 1.8;
        const playerWidth = 0.6;

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const highlightMesh = new THREE.Mesh(
            new THREE.BoxGeometry(1.001, 1.001, 1.001),
            new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true })
        );
        scene.add(highlightMesh);
        highlightMesh.visible = false;

        const objects = [mesh]; // Objects to intersect (initially just the ground)

        document.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;

            if (highlightMesh.visible) {
                if (event.button === 0) { // Left click: Remove
                    const intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const instanceId = intersect.instanceId;

                        let blockPos;
                        if (instanceId !== undefined) {
                            const matrix = new THREE.Matrix4();
                            mesh.getMatrixAt(instanceId, matrix);
                            blockPos = new THREE.Vector3().setFromMatrixPosition(matrix);

                            matrix.scale(new THREE.Vector3(0, 0, 0));
                            mesh.setMatrixAt(instanceId, matrix);
                            mesh.instanceMatrix.needsUpdate = true;
                        } else {
                            blockPos = intersect.object.position.clone();
                            scene.remove(intersect.object);
                            objects.splice(objects.indexOf(intersect.object), 1);
                        }

                        world.delete(getChunkKey(Math.round(blockPos.x), Math.round(blockPos.y), Math.round(blockPos.z)));
                    }
                } else if (event.button === 2) { // Right click: Place
                    const intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0) {
                        const intersect = intersects[0];

                        // Fix: Use Math.round to find integer center, NOT floor + 0.5
                        const voxelPos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.5));
                        voxelPos.x = Math.round(voxelPos.x);
                        voxelPos.y = Math.round(voxelPos.y);
                        voxelPos.z = Math.round(voxelPos.z);

                        // Check if player is inside the block we are trying to place
                        const playerPos = controls.getObject().position;
                        const dx = Math.abs(playerPos.x - voxelPos.x);
                        const dz = Math.abs(playerPos.z - voxelPos.z);
                        const dy = playerPos.y - voxelPos.y;

                        if (dx < playerWidth / 2 + 0.5 && dz < playerWidth / 2 + 0.5) {
                            if (dy > -1.0 && dy < 1.8) {
                                return;
                            }
                        }

                        const voxel = new THREE.Mesh(geometry, material);
                        voxel.position.copy(voxelPos);
                        voxel.castShadow = true;
                        voxel.receiveShadow = true;
                        scene.add(voxel);
                        objects.push(voxel);

                        world.set(getChunkKey(Math.round(voxelPos.x), Math.round(voxelPos.y), Math.round(voxelPos.z)), true);
                    }
                }
            }
        });

        function checkCollision(position) {
            const x = Math.round(position.x);
            const y = Math.round(position.y);
            const z = Math.round(position.z);
            return world.has(getChunkKey(x, y, z));
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);

            if (controls.isLocked === true) {

                // Friction
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // Gravity

                // Get camera direction
                const forward = new THREE.Vector3();
                controls.getDirection(forward);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();

                // Calculate input direction in world space
                const inputVector = new THREE.Vector3();
                if (moveForward) inputVector.add(forward);
                if (moveBackward) inputVector.sub(forward);
                if (moveRight) inputVector.add(right);
                if (moveLeft) inputVector.sub(right);
                inputVector.normalize();

                // Apply movement force
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    velocity.x += inputVector.x * 100.0 * delta;
                    velocity.z += inputVector.z * 100.0 * delta;
                }

                // Collision Detection
                const playerObj = controls.getObject();
                const originalPos = playerObj.position.clone();

                // 1. Apply X movement
                playerObj.position.x += velocity.x * delta;
                if (checkHorizontalCollision(playerObj.position)) {
                    playerObj.position.x = originalPos.x;
                    velocity.x = 0;
                }

                // 2. Apply Z movement
                playerObj.position.z += velocity.z * delta;
                if (checkHorizontalCollision(playerObj.position)) {
                    playerObj.position.z = originalPos.z;
                    velocity.z = 0;
                }

                // 3. Apply Y movement
                playerObj.position.y += velocity.y * delta;

                // Ground/Ceiling Check
                if (velocity.y < 0) {
                    if (checkVerticalCollision(playerObj.position, true)) {
                        velocity.y = 0;
                        canJump = true;
                        const feetY = playerObj.position.y - 1.5;
                        const blockY = Math.round(feetY);
                        playerObj.position.y = blockY + 0.5 + 1.5;
                    }
                }
                else if (velocity.y > 0) {
                    if (checkVerticalCollision(playerObj.position, false)) {
                        velocity.y = 0;
                        playerObj.position.y = Math.floor(playerObj.position.y + 0.1) - 0.1 - 0.1;
                    }
                }

                if (playerObj.position.y < -10) {
                    velocity.y = 0;
                    playerObj.position.set(0, 10, 0);
                }

                // Raycasting
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    // Fix: Use Math.round for highlight target too
                    const lookTarget = intersect.point.clone().sub(intersect.face.normal.clone().multiplyScalar(0.1));
                    lookTarget.x = Math.round(lookTarget.x);
                    lookTarget.y = Math.round(lookTarget.y);
                    lookTarget.z = Math.round(lookTarget.z);

                    highlightMesh.position.copy(lookTarget);
                    highlightMesh.visible = true;
                } else {
                    highlightMesh.visible = false;
                }
            }

            prevTime = time;

            renderer.render(scene, camera);
        }

        function checkHorizontalCollision(pos) {
            const x = pos.x;
            const y = pos.y;
            const z = pos.z;
            const w = 0.3; // Half width

            // Check legs (y-1.4), waist (y-0.8), and head (y+0.1)
            // We avoid checking exactly at feet (y-1.5) to prevent getting stuck on the floor

            const points = [
                // Legs
                new THREE.Vector3(x - w, y - 1.4, z - w),
                new THREE.Vector3(x + w, y - 1.4, z - w),
                new THREE.Vector3(x - w, y - 1.4, z + w),
                new THREE.Vector3(x + w, y - 1.4, z + w),

                // Waist
                new THREE.Vector3(x - w, y - 0.8, z - w),
                new THREE.Vector3(x + w, y - 0.8, z - w),
                new THREE.Vector3(x - w, y - 0.8, z + w),
                new THREE.Vector3(x + w, y - 0.8, z + w),

                // Head
                new THREE.Vector3(x, y + 0.1, z)
            ];

            for (const p of points) {
                if (checkCollision(p)) return true;
            }
            return false;
        }

        function checkVerticalCollision(pos, isFalling) {
            const x = pos.x;
            const y = pos.y;
            const z = pos.z;
            const w = 0.3;

            const points = [];

            if (isFalling) {
                // Check feet
                points.push(
                    new THREE.Vector3(x - w, y - 1.5, z - w),
                    new THREE.Vector3(x + w, y - 1.5, z - w),
                    new THREE.Vector3(x - w, y - 1.5, z + w),
                    new THREE.Vector3(x + w, y - 1.5, z + w)
                );
            } else {
                // Check head
                points.push(new THREE.Vector3(x, y + 0.1, z));
            }

            for (const p of points) {
                if (checkCollision(p)) return true;
            }
            return false;
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>